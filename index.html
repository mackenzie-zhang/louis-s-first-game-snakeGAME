<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Louisçš„å½©è™¹è´ªåƒè›‡</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
        }
        
        .game-container {
            text-align: center;
            background: white;
            padding: 15px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 95vw;
            width: 100%;
            max-width: 500px;
        }
        
        h1 {
            color: #5a67d8;
            margin: 5px 0;
            font-size: clamp(20px, 5vw, 28px);
        }
        
        canvas {
            border: 3px solid #5a67d8;
            border-radius: 10px;
            background: #f0f0f0;
            width: 100%;
            max-width: 400px;
            height: auto;
            touch-action: none;
        }
        
        .score {
            font-size: clamp(18px, 4vw, 24px);
            color: #5a67d8;
            margin: 5px 0;
            font-weight: bold;
        }
        
        .level-info {
            font-size: clamp(16px, 3.5vw, 20px);
            color: #e53e3e;
            margin: 5px 0;
            font-weight: bold;
        }
        
        .lives-info {
            font-size: clamp(14px, 3vw, 18px);
            color: #48bb78;
            margin: 5px 0;
            font-weight: bold;
        }
        
        .skill-info {
            font-size: clamp(14px, 3vw, 18px);
            color: #48bb78;
            margin: 5px 0;
            font-weight: bold;
            min-height: 20px;
        }
        
        .controls {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        
        button {
            background: #5a67d8;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: clamp(14px, 3vw, 18px);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        button:hover {
            background: #667eea;
            transform: scale(1.05);
        }
        
        .skill-button {
            background: #48bb78;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
        }
        
        .skill-button:hover {
            background: #38a169;
        }
        
        .skill-button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: scale(1);
        }
        
        .instructions {
            margin-top: 20px;
            color: #5a67d8;
            font-size: 16px;
        }
        
        .game-over, .level-select, .leaderboard-modal, .name-input-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            z-index: 1000;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .game-over h2 {
            color: #e53e3e;
            margin-bottom: 10px;
        }
        
        .level-select h2, .leaderboard-modal h2 {
            color: #5a67d8;
            margin-bottom: 20px;
        }
        
        .level-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .level-button {
            background: #48bb78;
            padding: 15px 40px;
            font-size: 20px;
            transition: all 0.3s;
        }
        
        .level-button:hover {
            background: #38a169;
            transform: scale(1.1);
        }
        
        .level-button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: scale(1);
        }
        
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        .food-effect {
            position: absolute;
            font-size: 30px;
            animation: foodPop 0.5s ease-out;
            pointer-events: none;
        }
        
        .message-popup {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #e53e3e;
            animation: messageFade 2s ease-out;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        @keyframes foodPop {
            0% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
            100% {
                transform: scale(2) translateY(-30px);
                opacity: 0;
            }
        }
        
        @keyframes messageFade {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            20% {
                transform: scale(1.2);
                opacity: 1;
            }
            80% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(0.8);
                opacity: 0;
            }
        }
        
        .projectile {
            position: absolute;
            font-size: 20px;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .leaderboard-table {
            margin: 20px 0;
            width: 100%;
            border-collapse: collapse;
        }
        
        .leaderboard-table th, .leaderboard-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }
        
        .leaderboard-table th {
            background: #5a67d8;
            color: white;
            font-weight: bold;
        }
        
        .leaderboard-table tr:nth-child(even) {
            background: #f7fafc;
        }
        
        .leaderboard-table tr:first-child td {
            background: #ffd700;
            font-weight: bold;
        }
        
        .leaderboard-table tr:nth-child(2) td {
            background: #c0c0c0;
            font-weight: bold;
        }
        
        .leaderboard-table tr:nth-child(3) td {
            background: #cd7f32;
            font-weight: bold;
        }
        
        .name-input {
            margin: 20px 0;
        }
        
        .name-input input {
            padding: 10px 20px;
            font-size: 18px;
            border: 2px solid #5a67d8;
            border-radius: 10px;
            width: 200px;
            text-align: center;
        }
        
        .touch-controls {
            display: none;
            margin-top: 20px;
            gap: 10px;
        }
        
        .touch-row {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        .touch-button {
            background: #667eea;
            color: white;
            border: none;
            width: 80px;
            height: 80px;
            font-size: 30px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .touch-button:active {
            background: #5a67d8;
            transform: scale(0.95);
        }
        
        .touch-button.skill {
            background: #48bb78;
            width: auto;
            padding: 0 30px;
        }
        
        .touch-button.skill:active {
            background: #38a169;
        }
        
        @media (max-width: 768px) {
            .touch-controls {
                display: grid;
            }
            
            .instructions {
                display: none;
            }
            
            .game-container {
                padding: 10px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 90%;
                max-width: 200px;
            }
        }
        .heart {
            color: #e53e3e;
            font-size: 20px;
            display: inline-block;
            animation: heartBeat 1s infinite;
        }
        
        @keyframes heartBeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸŒˆ Louisçš„å½©è™¹è´ªåƒè›‡ ğŸ</h1>
        <div class="level-info">ç¬¬ <span id="currentLevel">1</span> å…³</div>
        <div class="score">å¾—åˆ†: <span id="score">0</span> åˆ†</div>
        <div class="lives-info" id="livesInfo"></div>
        <div class="skill-info" id="skillInfo"></div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div class="controls">
            <button onclick="showLevelSelect()">å¼€å§‹æ¸¸æˆ</button>
            <button onclick="pauseGame()">æš‚åœ</button>
            <button onclick="showLeaderboard()">æ’è¡Œæ¦œ</button>
        </div>
        
        <button id="skillButton" class="skill-button" onclick="useSkill()" style="display: none;">
            ä½¿ç”¨è¿œç¨‹åƒæŠ€èƒ½ (ç©ºæ ¼é”®)
        </button>
        
        <div class="touch-controls" id="touchControls">
            <div class="touch-row">
                <button class="touch-button" ontouchstart="handleTouchControl('up')" onmousedown="handleTouchControl('up')">â†‘</button>
            </div>
            <div class="touch-row">
                <button class="touch-button" ontouchstart="handleTouchControl('left')" onmousedown="handleTouchControl('left')">â†</button>
                <button class="touch-button skill" ontouchstart="useSkill()" onmousedown="useSkill()" id="touchSkillButton" style="display: none;">ğŸŸ</button>
                <button class="touch-button" ontouchstart="handleTouchControl('right')" onmousedown="handleTouchControl('right')">â†’</button>
            </div>
            <div class="touch-row">
                <button class="touch-button" ontouchstart="handleTouchControl('down')" onmousedown="handleTouchControl('down')">â†“</button>
            </div>
        </div>
        
        <div class="instructions">
            <p>ä½¿ç”¨æ–¹å‘é”® â†‘ â†“ â† â†’ æ§åˆ¶å°è›‡</p>
            <p id="skillInstruction" style="display: none;">æŒ‰ç©ºæ ¼é”®ä½¿ç”¨è¿œç¨‹åƒæŠ€èƒ½ï¼</p>
        </div>
    </div>
    
    <div class="overlay" id="overlay"></div>
    
    <div class="level-select" id="levelSelect">
        <h2>ğŸ® é€‰æ‹©å…³å¡ ğŸ®</h2>
        <div class="level-buttons">
            <button class="level-button" onclick="startLevel(1)">ç¬¬1å…³ - æ…¢æ…¢çˆ¬ ğŸ¢</button>
            <button class="level-button" id="level2Button" onclick="startLevel(2)">ç¬¬2å…³ - æ­£å¸¸é€Ÿåº¦ ğŸ</button>
            <button class="level-button" id="level3Button" onclick="startLevel(3)">ç¬¬3å…³ - å¿«å¿«è·‘ ğŸš€</button>
            <button class="level-button" id="level4Button" onclick="startLevel(4)">ç¬¬4å…³ - è¶…çº§å¿« âš¡ (+1å‘½)</button>
            <button class="level-button" id="level5Button" onclick="startLevel(5)">ç¬¬5å…³ - é—ªç”µä¾  âš¡âš¡</button>
            <button class="level-button" id="level6Button" onclick="startLevel(6)">ç¬¬6å…³ - å…‰é€Ÿ ğŸ’«</button>
            <button class="level-button" id="level7Button" onclick="startLevel(7)">ç¬¬7å…³ - ç»ˆææŒ‘æˆ˜ ğŸ”¥</button>
        </div>
    </div>
    
    <div class="game-over" id="gameOver">
        <h2>æ¸¸æˆç»“æŸï¼</h2>
        <p>æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span> åˆ†</p>
        <p>æ€»åˆ†: <span id="totalScore">0</span> åˆ†</p>
        <button onclick="checkHighScore()">æäº¤åˆ†æ•°</button>
        <button onclick="showLevelSelect()">é€‰æ‹©å…³å¡</button>
        <button onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
    </div>
    
    <div class="name-input-modal" id="nameInputModal">
        <h2>ğŸ† æ­å–œï¼ä½ è¿›å…¥äº†å‰10åï¼ ğŸ†</h2>
        <p>ä½ çš„æ€»åˆ†: <span id="highScoreDisplay">0</span> åˆ†</p>
        <div class="name-input">
            <input type="text" id="playerName" placeholder="è¾“å…¥ä½ çš„åå­—" maxlength="10">
        </div>
        <button onclick="submitHighScore()">æäº¤</button>
        <button onclick="cancelSubmit()">å–æ¶ˆ</button>
    </div>
    
    <div class="leaderboard-modal" id="leaderboardModal">
        <h2>ğŸ† æ’è¡Œæ¦œ TOP 10 ğŸ†</h2>
        <table class="leaderboard-table">
            <thead>
                <tr>
                    <th>æ’å</th>
                    <th>ç©å®¶</th>
                    <th>æ€»åˆ†</th>
                    <th>æ—¥æœŸ</th>
                </tr>
            </thead>
            <tbody id="leaderboardBody"></tbody>
        </table>
        <button onclick="closeLeaderboard()">å…³é—­</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('currentLevel');
        const gameOverDiv = document.getElementById('gameOver');
        const levelSelectDiv = document.getElementById('levelSelect');
        const overlay = document.getElementById('overlay');
        const finalScoreElement = document.getElementById('finalScore');
        const totalScoreElement = document.getElementById('totalScore');
        const skillButton = document.getElementById('skillButton');
        const skillInfo = document.getElementById('skillInfo');
        const skillInstruction = document.getElementById('skillInstruction');
        const livesInfo = document.getElementById('livesInfo');
        const leaderboardModal = document.getElementById('leaderboardModal');
        const nameInputModal = document.getElementById('nameInputModal');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const touchControls = document.getElementById('touchControls');
        const touchSkillButton = document.getElementById('touchSkillButton');
        
        // æ¸¸æˆè®¾ç½®
        const gridSize = 20;
        
        // è§¦æ‘¸æ§åˆ¶å¤„ç†
        function handleTouchControl(direction) {
            if (!gameRunning || gamePaused) return;
            
            switch(direction) {
                case 'up':
                    if (dy === 0) { dx = 0; dy = -1; }
                    break;
                case 'down':
                    if (dy === 0) { dx = 0; dy = 1; }
                    break;
                case 'left':
                    if (dx === 0) { dx = -1; dy = 0; }
                    break;
                case 'right':
                    if (dx === 0) { dx = 1; dy = 0; }
                    break;
            }
        }
        
        // è§¦æ‘¸æ»‘åŠ¨æ§åˆ¶
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        });
        
        canvas.addEventListener('touchend', (e) => {
            if (!gameRunning || gamePaused) return;
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            
            if (Math.abs(diffX) > Math.abs(diffY)) {
                if (diffX > 30) { handleTouchControl('right'); } 
                else if (diffX < -30) { handleTouchControl('left'); }
            } else {
                if (diffY > 30) { handleTouchControl('down'); } 
                else if (diffY < -30) { handleTouchControl('up'); }
            }
            e.preventDefault();
        });
        
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas) { e.preventDefault(); }
        }, { passive: false });
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const maxSize = Math.min(container.clientWidth - 30, 400);
            canvas.width = maxSize;
            canvas.height = maxSize;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        let snake = [{x: 10, y: 10}];
        let foods = [];
        let dx = 0;
        let dy = 0;
        let score = 0;
        let totalGameScore = 0;
        let gameRunning = false;
        let gamePaused = false;
        let currentLevel = 1;
        let gameSpeed = 150;
        let gameInterval = null;
        let completedLevels = [];
        let skillUnlocked = false;
        let skillCooldown = 0;
        let skillCooldownInterval = null;
        let lives = 1;
        let maxLives = 1;
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playEatSound() {
            const notes = [261.63, 329.63, 392.00, 523.25, 659.25, 783.99, 1046.50];
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.type = index % 2 === 0 ? 'sine' : 'triangle';
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    const vibrato = audioContext.createOscillator();
                    vibrato.frequency.value = 5;
                    const vibratoGain = audioContext.createGain();
                    vibratoGain.gain.value = 10;
                    vibrato.connect(vibratoGain);
                    vibratoGain.connect(oscillator.frequency);
                    vibrato.start();
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    vibrato.stop(audioContext.currentTime + 0.3);
                }, index * 40);
            });
        }
        
        function playMissSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        function playSkillSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }
        
        function playLevelUpSound() {
            const notes = [261.63, 329.63, 392.00, 523.25, 659.25];
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                }, index * 100);
            });
        }
        
        function playGameOverSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.5);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        function playExtraLifeSound() {
            const notes = [523.25, 587.33, 659.25, 783.99];
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                }, index * 100);
            });
        }
        
        const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
        const foodEmojis = ['ğŸ', 'ğŸ“', 'ğŸŠ', 'ğŸ‹', 'ğŸ‡', 'ğŸ‰', 'ğŸ’', 'ğŸŒ', 'ğŸ¥', 'ğŸ‘'];
        
        function showMessage(message, x, y) {
            const msg = document.createElement('div');
            msg.className = 'message-popup';
            msg.textContent = message;
            msg.style.left = (canvas.offsetLeft + x * gridSize) + 'px';
            msg.style.top = (canvas.offsetTop + y * gridSize - 40) + 'px';
            document.body.appendChild(msg);
            setTimeout(() => { msg.remove(); }, 2000);
        }
        
        function updateLivesDisplay() {
            if (currentLevel >= 4) {
                livesInfo.innerHTML = `ç”Ÿå‘½: ${'<span class="heart">â¤ï¸</span>'.repeat(lives)}`;
                livesInfo.style.display = 'block';
            } else {
                livesInfo.style.display = 'none';
            }
        }
        
        function useSkill() {
            if (!gameRunning || gamePaused || skillCooldown > 0 || !skillUnlocked) return;
            const head = snake[0];
            let targetFood = null;
            let minDistance = Infinity;
            foods.forEach(food => {
                const distance = Math.abs(food.x - head.x) + Math.abs(food.y - head.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    targetFood = food;
                }
            });
            if (targetFood) {
                playSkillSound();
                const projectile = document.createElement('div');
                projectile.className = 'projectile';
                projectile.textContent = 'ğŸŸ';
                projectile.style.left = (canvas.offsetLeft + head.x * gridSize) + 'px';
                projectile.style.top = (canvas.offsetTop + head.y * gridSize) + 'px';
                document.body.appendChild(projectile);
                setTimeout(() => {
                    projectile.style.transition = 'all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    projectile.style.left = (canvas.offsetLeft + targetFood.x * gridSize) + 'px';
                    projectile.style.top = (canvas.offsetTop + targetFood.y * gridSize) + 'px';
                }, 50);
                setTimeout(() => {
                    projectile.remove();
                    const foodIndex = foods.indexOf(targetFood);
                    if (foodIndex !== -1) {
                        foods.splice(foodIndex, 1);
                        score += 10;
                        scoreElement.textContent = score;
                        playEatSound();
                        createFoodEffect(targetFood.x, targetFood.y, targetFood.emoji);
                        generateSingleFood();
                        snake.push({...snake[snake.length - 1]});
                    }
                }, 550);
                skillCooldown = 30;
                updateSkillButton();
                if (skillCooldownInterval) { clearInterval(skillCooldownInterval); }
                skillCooldownInterval = setInterval(() => {
                    skillCooldown--;
                    updateSkillButton();
                    if (skillCooldown <= 0) {
                        clearInterval(skillCooldownInterval);
                        skillCooldownInterval = null;
                    }
                }, 1000);
            } else {
                playMissSound();
                showMessage("ä¸‹æ¬¡å†åŠªåŠ›ï¼", head.x, head.y);
            }
        }
        
        function updateSkillButton() {
            if (!skillUnlocked) {
                skillButton.style.display = 'none';
                touchSkillButton.style.display = 'none';
                skillInfo.textContent = '';
                return;
            }
            skillButton.style.display = 'block';
            if (isMobile && gameRunning) {
                touchSkillButton.style.display = 'flex';
            }
            if (skillCooldown > 0) {
                skillButton.disabled = true;
                touchSkillButton.disabled = true;
                skillButton.textContent = `æŠ€èƒ½å†·å´ä¸­ (${skillCooldown}ç§’)`;
                touchSkillButton.textContent = `${skillCooldown}`;
                skillInfo.textContent = `â±ï¸ æŠ€èƒ½å†·å´: ${skillCooldown}ç§’`;
            } else {
                skillButton.disabled = false;
                touchSkillButton.disabled = false;
                skillButton.textContent = 'ä½¿ç”¨è¿œç¨‹åƒæŠ€èƒ½ (ç©ºæ ¼é”®)';
                touchSkillButton.textContent = 'ğŸŸ';
                skillInfo.textContent = 'ğŸŸ è¿œç¨‹åƒæŠ€èƒ½å·²å°±ç»ªï¼';
            }
        }
        
        function generateSingleFood() {
            const actualTileCount = Math.floor(canvas.width / gridSize);
            let newFood;
            let attempts = 0;
            do {
                newFood = {
                    x: Math.floor(Math.random() * actualTileCount),
                    y: Math.floor(Math.random() * actualTileCount),
                    emoji: foodEmojis[Math.floor(Math.random() * foodEmojis.length)]
                };
                attempts++;
                let valid = !snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) && 
                            !foods.some(food => food.x === newFood.x && food.y === newFood.y);
                if (valid) {
                    foods.push(newFood);
                    return;
                }
            } while (attempts < 100);
        }
        
        function initializeFoods() {
            foods = [];
            for (let i = 0; i < 3; i++) {
                generateSingleFood();
            }
        }
        
        function createFoodEffect(x, y, emoji) {
            const effect = document.createElement('div');
            effect.className = 'food-effect';
            effect.textContent = emoji;
            effect.style.left = (canvas.offsetLeft + x * gridSize) + 'px';
            effect.style.top = (canvas.offsetTop + y * gridSize - 20) + 'px';
            document.body.appendChild(effect);
            setTimeout(() => { effect.remove(); }, 500);
        }
        
        function draw() {
            const actualTileCount = Math.floor(canvas.width / gridSize);
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= actualTileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }
            snake.forEach((segment, index) => {
                ctx.fillStyle = rainbowColors[index % rainbowColors.length];
                ctx.fillRect(segment.x * gridSize + 2, segment.y * gridSize + 2, gridSize - 4, gridSize - 4);
                if (index === 0) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(segment.x * gridSize + 6, segment.y * gridSize + 6, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * gridSize + 14, segment.y * gridSize + 6, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(segment.x * gridSize + 6, segment.y * gridSize + 6, 1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * gridSize + 14, segment.y * gridSize + 6, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            foods.forEach(food => {
                ctx.font = `${gridSize - 4}px Arial`;
                ctx.fillText(food.emoji, food.x * gridSize + 2, food.y * gridSize + gridSize - 4);
            });
        }
        
        function update() {
            if (!gameRunning || gamePaused || (dx === 0 && dy === 0)) return;
            const actualTileCount = Math.floor(canvas.width / gridSize);
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            if (head.x < 0 || head.x >= actualTileCount || head.y < 0 || head.y >= actualTileCount || snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                handleDeath();
                return;
            }
            snake.unshift(head);
            const foodIndex = foods.findIndex(food => head.x === food.x && head.y === food.y);
            if (foodIndex !== -1) {
                score += 10;
                scoreElement.textContent = score;
                playEatSound();
                createFoodEffect(foods[foodIndex].x, foods[foodIndex].y, foods[foodIndex].emoji);
                foods.splice(foodIndex, 1);
                generateSingleFood();
            } else {
                snake.pop();
            }
            if (score >= currentLevel * 30) {
                levelComplete();
            }
            draw();
        }
        
        function handleDeath() {
            if (lives > 1) {
                lives--;
                updateLivesDisplay();
                playMissSound();
                showMessage("è¿˜æœ‰ä¸€æ¬¡æœºä¼šï¼", Math.floor(canvas.width / gridSize / 2), Math.floor(canvas.height / gridSize / 2));
                const startX = Math.floor(canvas.width / gridSize / 2);
                const startY = Math.floor(canvas.height / gridSize / 2);
                snake = [{x: startX, y: startY}];
                dx = 0; dy = 0;
                draw();
            } else {
                gameOver();
            }
        }
        
        function levelComplete() {
            gameRunning = false;
            if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
            totalGameScore += score;
            if (!completedLevels.includes(currentLevel)) {
                completedLevels.push(currentLevel);
                localStorage.setItem('completedLevels', JSON.stringify(completedLevels));
            }
            if (currentLevel === 1 && !skillUnlocked) {
                skillUnlocked = true;
                localStorage.setItem('skillUnlocked', 'true');
                alert('æ­å–œï¼ä½ è§£é”äº†è¿œç¨‹åƒæŠ€èƒ½ï¼æŒ‰ç©ºæ ¼é”®ä½¿ç”¨ï¼');
            }
            playLevelUpSound();
            if (currentLevel === 7) {
                alert(`æ­å–œé€šè¿‡æ‰€æœ‰å…³å¡ï¼æ€»åˆ†: ${totalGameScore}`);
                finalScoreElement.textContent = score;
                totalScoreElement.textContent = totalGameScore;
                overlay.style.display = 'block';
                gameOverDiv.style.display = 'block';
            } else {
                alert(`æ­å–œé€šè¿‡ç¬¬${currentLevel}å…³ï¼`);
                showLevelSelect();
            }
        }
        
        function gameOver() {
            gameRunning = false;
            playGameOverSound();
            totalGameScore += score;
            finalScoreElement.textContent = score;
            totalScoreElement.textContent = totalGameScore;
            overlay.style.display = 'block';
            gameOverDiv.style.display = 'block';
            if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
            if (skillCooldownInterval) { clearInterval(skillCooldownInterval); skillCooldownInterval = null; }
        }
        
        async function checkHighScore() {
            const leaderboard = await getLeaderboard();
            if (leaderboard.length < 10 || totalGameScore > (leaderboard[9]?.score || 0)) {
                highScoreDisplay.textContent = totalGameScore;
                overlay.style.display = 'block';
                gameOverDiv.style.display = 'none';
                nameInputModal.style.display = 'block';
            } else {
                showLeaderboard();
            }
        }

        async function submitHighScore() {
            const playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                alert('è¯·è¾“å…¥ä½ çš„åå­—ï¼');
                return;
            }
            try {
                const leaderboard = await getLeaderboard();
                const date = new Date().toLocaleDateString('zh-CN');
                leaderboard.push({ name: playerName, score: totalGameScore, date: date });
                leaderboard.sort((a, b) => b.score - a.score);
                leaderboard.splice(10);
                const response = await fetch('/api/setLeaderboard', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(leaderboard),
                });
                if (!response.ok) {
                    throw new Error(`APIè¿”å›é”™è¯¯ï¼ŒçŠ¶æ€ç : ${response.status}`);
                }
                showLeaderboard();
            } catch (error) {
                console.error("æäº¤è¿‡ç¨‹ä¸­æ–­ï¼é”™è¯¯è¯¦æƒ…:", error);
                alert('ç½‘ç»œé”™è¯¯ï¼Œæäº¤åˆ†æ•°å¤±è´¥ã€‚è¯·ç¨åå†è¯•ã€‚');
            }
        }
        
        function cancelSubmit() {
            nameInputModal.style.display = 'none';
            showLevelSelect();
        }
        
        async function getLeaderboard() {
            try {
                const response = await fetch('/api/getLeaderboard');
                if (!response.ok) {
                    console.error("Failed to fetch leaderboard from server.");
                    return [];
                }
                return await response.json();
            } catch (error) {
                console.error("Error fetching leaderboard:", error);
                return [];
            }
        }

        async function showLeaderboard() {
            try {
                const leaderboard = await getLeaderboard();
                const tbody = document.getElementById('leaderboardBody');
                if (!tbody) {
                    console.error("showLeaderboard é”™è¯¯ï¼šæ‰¾ä¸åˆ°å…ƒç´  'leaderboardBody'!");
                    return;
                }
                tbody.innerHTML = '';
                if (!Array.isArray(leaderboard)) {
                    console.error("showLeaderboard é”™è¯¯ï¼šä»APIè·å–åˆ°çš„ leaderboard ä¸æ˜¯ä¸€ä¸ªæ•°ç»„!", leaderboard);
                    return;
                }
                leaderboard.forEach((entry, index) => {
                    const row = tbody.insertRow();
                    row.insertCell(0).textContent = index + 1;
                    row.insertCell(1).textContent = entry.name;
                    row.insertCell(2).textContent = entry.score + ' åˆ†';
                    row.insertCell(3).textContent = entry.date;
                });
                overlay.style.display = 'block';
                leaderboardModal.style.display = 'block';
                gameOverDiv.style.display = 'none';
                nameInputModal.style.display = 'none';
            } catch (error) {
                console.error("showLeaderboard å‡½æ•°å†…éƒ¨å‘ç”Ÿè‡´å‘½é”™è¯¯:", error);
                alert("æ˜¾ç¤ºæ’è¡Œæ¦œæ—¶å‘ç”Ÿäº†ä¸€ä¸ªå†…éƒ¨é”™è¯¯ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°ï¼");
            }
        }
        
        function closeLeaderboard() {
            leaderboardModal.style.display = 'none';
            overlay.style.display = 'none';
        }
        
        function showLevelSelect() {
            overlay.style.display = 'block';
            levelSelectDiv.style.display = 'block';
            gameOverDiv.style.display = 'none';
            totalGameScore = 0;
            updateLevelButtons();
        }
        
        function updateLevelButtons() {
            for (let i = 2; i <= 7; i++) {
                const button = document.getElementById(`level${i}Button`);
                if (completedLevels.includes(i - 1)) {
                    button.disabled = false;
                    button.textContent = [`ç¬¬2å…³ - æ­£å¸¸é€Ÿåº¦ ğŸ`, `ç¬¬3å…³ - å¿«å¿«è·‘ ğŸš€`, `ç¬¬4å…³ - è¶…çº§å¿« âš¡ (+1å‘½)`, `ç¬¬5å…³ - é—ªç”µä¾  âš¡âš¡`, `ç¬¬6å…³ - å…‰é€Ÿ ğŸ’«`, `ç¬¬7å…³ - ç»ˆææŒ‘æˆ˜ ğŸ”¥`][i-2];
                } else {
                    button.disabled = true;
                    button.textContent = `ç¬¬${i}å…³ - éœ€è¦é€šè¿‡ç¬¬${i-1}å…³`;
                }
            }
        }
        
        function startLevel(level) {
            currentLevel = level;
            levelElement.textContent = level;
            const speeds = [200, 150, 120, 100, 80, 70, 60];
            const livesConfig = [1, 1, 1, 2, 2, 2, 2];
            gameSpeed = speeds[level-1];
            maxLives = livesConfig[level-1];
            lives = maxLives;
            updateLivesDisplay();
            overlay.style.display = 'none';
            levelSelectDiv.style.display = 'none';
            if (skillUnlocked) {
                skillInstruction.style.display = 'block';
            }
            if (level === 4 && lives === 2) {
                playExtraLifeSound();
                showMessage("è·å¾—é¢å¤–ç”Ÿå‘½ï¼", 10, 10);
            }
            playLevelUpSound();
            startGame();
        }
        
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gamePaused) return;
            const keyMap = {
                'ArrowUp': {dx: 0, dy: -1, condition: dy === 0},
                'ArrowDown': {dx: 0, dy: 1, condition: dy === 0},
                'ArrowLeft': {dx: -1, dy: 0, condition: dx === 0},
                'ArrowRight': {dx: 1, dy: 0, condition: dx === 0},
            };
            if (keyMap[e.key] && keyMap[e.key].condition) {
                dx = keyMap[e.key].dx;
                dy = keyMap[e.key].dy;
            } else if (e.key === ' ') {
                e.preventDefault();
                useSkill();
            }
        });
        
        function startGame() {
            if (gameInterval) { clearInterval(gameInterval); }
            const startX = Math.floor(canvas.width / gridSize / 2);
            const startY = Math.floor(canvas.height / gridSize / 2);
            snake = [{x: startX, y: startY}];
            dx = 0; dy = 0;
            score = 0;
            scoreElement.textContent = score;
            skillCooldown = 0;
            initializeFoods();
            gameRunning = true;
            gamePaused = false;
            if (isMobile) {
                touchControls.style.display = 'grid';
            }
            updateSkillButton();
            gameInterval = setInterval(update, gameSpeed);
            draw();
        }
        
        function pauseGame() {
            if (gameRunning) {
                gamePaused = !gamePaused;
            }
        }
        
        function restartGame() {
            overlay.style.display = 'none';
            gameOverDiv.style.display = 'none';
            totalGameScore = 0;
            startLevel(currentLevel);
        }
        
        function loadProgress() {
            const savedLevels = localStorage.getItem('completedLevels');
            if (savedLevels) {
                completedLevels = JSON.parse(savedLevels);
            }
            const savedSkill = localStorage.getItem('skillUnlocked');
            if (savedSkill === 'true') {
                skillUnlocked = true;
            }
        }
        
        loadProgress();
        initializeFoods();
        draw();
    </script>
</body>
</html>

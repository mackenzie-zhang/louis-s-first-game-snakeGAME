<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Louisçš„å½©è™¹è´ªåƒè›‡</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        
        .game-container {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #5a67d8;
            margin: 10px 0;
            font-size: 28px;
        }
        
        canvas {
            border: 3px solid #5a67d8;
            border-radius: 10px;
            background: #f0f0f0;
        }
        
        .score {
            font-size: 24px;
            color: #5a67d8;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .level-info {
            font-size: 20px;
            color: #e53e3e;
            margin: 5px 0;
            font-weight: bold;
        }
        
        .lives-info {
            font-size: 18px;
            color: #48bb78;
            margin: 5px 0;
            font-weight: bold;
        }
        
        .skill-info {
            font-size: 18px;
            color: #48bb78;
            margin: 5px 0;
            font-weight: bold;
            min-height: 25px;
        }
        
        .controls {
            margin-top: 20px;
        }
        
        button {
            background: #5a67d8;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #667eea;
            transform: scale(1.05);
        }
        
        .skill-button {
            background: #48bb78;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
        }
        
        .skill-button:hover {
            background: #38a169;
        }
        
        .skill-button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: scale(1);
        }
        
        .instructions {
            margin-top: 20px;
            color: #5a67d8;
            font-size: 16px;
        }
        
        .game-over, .level-select, .leaderboard-modal, .name-input-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            z-index: 1000;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .game-over h2 {
            color: #e53e3e;
            margin-bottom: 10px;
        }
        
        .level-select h2, .leaderboard-modal h2 {
            color: #5a67d8;
            margin-bottom: 20px;
        }
        
        .level-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .level-button {
            background: #48bb78;
            padding: 15px 40px;
            font-size: 20px;
            transition: all 0.3s;
        }
        
        .level-button:hover {
            background: #38a169;
            transform: scale(1.1);
        }
        
        .level-button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: scale(1);
        }
        
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        .food-effect {
            position: absolute;
            font-size: 30px;
            animation: foodPop 0.5s ease-out;
            pointer-events: none;
        }
        
        .message-popup {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #e53e3e;
            animation: messageFade 2s ease-out;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        @keyframes foodPop {
            0% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
            100% {
                transform: scale(2) translateY(-30px);
                opacity: 0;
            }
        }
        
        @keyframes messageFade {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            20% {
                transform: scale(1.2);
                opacity: 1;
            }
            80% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(0.8);
                opacity: 0;
            }
        }
        
        .projectile {
            position: absolute;
            font-size: 20px;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .leaderboard-table {
            margin: 20px 0;
            width: 100%;
            border-collapse: collapse;
        }
        
        .leaderboard-table th, .leaderboard-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }
        
        .leaderboard-table th {
            background: #5a67d8;
            color: white;
            font-weight: bold;
        }
        
        .leaderboard-table tr:nth-child(even) {
            background: #f7fafc;
        }
        
        .leaderboard-table tr:first-child td {
            background: #ffd700;
            font-weight: bold;
        }
        
        .leaderboard-table tr:nth-child(2) td {
            background: #c0c0c0;
            font-weight: bold;
        }
        
        .leaderboard-table tr:nth-child(3) td {
            background: #cd7f32;
            font-weight: bold;
        }
        
        .name-input {
            margin: 20px 0;
        }
        
        .name-input input {
            padding: 10px 20px;
            font-size: 18px;
            border: 2px solid #5a67d8;
            border-radius: 10px;
            width: 200px;
            text-align: center;
        }
        
        .heart {
            color: #e53e3e;
            font-size: 20px;
            display: inline-block;
            animation: heartBeat 1s infinite;
        }
        
        @keyframes heartBeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸŒˆ Louisçš„å½©è™¹è´ªåƒè›‡ ğŸ</h1>
        <div class="level-info">ç¬¬ <span id="currentLevel">1</span> å…³</div>
        <div class="score">å¾—åˆ†: <span id="score">0</span> åˆ†</div>
        <div class="lives-info" id="livesInfo"></div>
        <div class="skill-info" id="skillInfo"></div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div class="controls">
            <button onclick="showLevelSelect()">å¼€å§‹æ¸¸æˆ</button>
            <button onclick="pauseGame()">æš‚åœ</button>
            <button onclick="showLeaderboard()">æ’è¡Œæ¦œ</button>
        </div>
        
        <button id="skillButton" class="skill-button" onclick="useSkill()" style="display: none;">
            ä½¿ç”¨è¿œç¨‹åƒæŠ€èƒ½ (ç©ºæ ¼é”®)
        </button>
        
        <div class="instructions">
            <p>ä½¿ç”¨æ–¹å‘é”® â†‘ â†“ â† â†’ æ§åˆ¶å°è›‡</p>
            <p id="skillInstruction" style="display: none;">æŒ‰ç©ºæ ¼é”®ä½¿ç”¨è¿œç¨‹åƒæŠ€èƒ½ï¼</p>
        </div>
    </div>
    
    <div class="overlay" id="overlay"></div>
    
    <div class="level-select" id="levelSelect">
        <h2>ğŸ® é€‰æ‹©å…³å¡ ğŸ®</h2>
        <div class="level-buttons">
            <button class="level-button" onclick="startLevel(1)">ç¬¬1å…³ - æ…¢æ…¢çˆ¬ ğŸ¢</button>
            <button class="level-button" id="level2Button" onclick="startLevel(2)">ç¬¬2å…³ - æ­£å¸¸é€Ÿåº¦ ğŸ</button>
            <button class="level-button" id="level3Button" onclick="startLevel(3)">ç¬¬3å…³ - å¿«å¿«è·‘ ğŸš€</button>
            <button class="level-button" id="level4Button" onclick="startLevel(4)">ç¬¬4å…³ - è¶…çº§å¿« âš¡ (+1å‘½)</button>
            <button class="level-button" id="level5Button" onclick="startLevel(5)">ç¬¬5å…³ - é—ªç”µä¾  âš¡âš¡</button>
            <button class="level-button" id="level6Button" onclick="startLevel(6)">ç¬¬6å…³ - å…‰é€Ÿ ğŸ’«</button>
            <button class="level-button" id="level7Button" onclick="startLevel(7)">ç¬¬7å…³ - ç»ˆææŒ‘æˆ˜ ğŸ”¥</button>
        </div>
    </div>
    
    <div class="game-over" id="gameOver">
        <h2>æ¸¸æˆç»“æŸï¼</h2>
        <p>æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span> åˆ†</p>
        <p>æ€»åˆ†: <span id="totalScore">0</span> åˆ†</p>
        <button onclick="checkHighScore()">æäº¤åˆ†æ•°</button>
        <button onclick="showLevelSelect()">é€‰æ‹©å…³å¡</button>
        <button onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
    </div>
    
    <div class="name-input-modal" id="nameInputModal">
        <h2>ğŸ† æ­å–œï¼ä½ è¿›å…¥äº†å‰10åï¼ ğŸ†</h2>
        <p>ä½ çš„æ€»åˆ†: <span id="highScoreDisplay">0</span> åˆ†</p>
        <div class="name-input">
            <input type="text" id="playerName" placeholder="è¾“å…¥ä½ çš„åå­—" maxlength="10">
        </div>
        <button onclick="submitHighScore()">æäº¤</button>
        <button onclick="cancelSubmit()">å–æ¶ˆ</button>
    </div>
    
    <div class="leaderboard-modal" id="leaderboardModal">
        <h2>ğŸ† æ’è¡Œæ¦œ TOP 10 ğŸ†</h2>
        <table class="leaderboard-table">
            <thead>
                <tr>
                    <th>æ’å</th>
                    <th>ç©å®¶</th>
                    <th>æ€»åˆ†</th>
                    <th>æ—¥æœŸ</th>
                </tr>
            </thead>
            <tbody id="leaderboardBody"></tbody>
        </table>
        <button onclick="closeLeaderboard()">å…³é—­</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('currentLevel');
        const gameOverDiv = document.getElementById('gameOver');
        const levelSelectDiv = document.getElementById('levelSelect');
        const overlay = document.getElementById('overlay');
        const finalScoreElement = document.getElementById('finalScore');
        const totalScoreElement = document.getElementById('totalScore');
        const skillButton = document.getElementById('skillButton');
        const skillInfo = document.getElementById('skillInfo');
        const skillInstruction = document.getElementById('skillInstruction');
        const livesInfo = document.getElementById('livesInfo');
        const leaderboardModal = document.getElementById('leaderboardModal');
        const nameInputModal = document.getElementById('nameInputModal');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        
        // æ¸¸æˆè®¾ç½®
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;
        
        let snake = [{x: 10, y: 10}];
        let foods = [];
        let dx = 0;
        let dy = 0;
        let score = 0;
        let totalGameScore = 0;
        let gameRunning = false;
        let gamePaused = false;
        let currentLevel = 1;
        let gameSpeed = 150;
        let gameInterval = null;
        let completedLevels = [];
        let skillUnlocked = false;
        let skillCooldown = 0;
        let skillCooldownInterval = null;
        let lives = 1;
        let maxLives = 1;
        
        // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // æ’­æ”¾æ¬¢ä¹çš„åƒé£Ÿç‰©éŸ³æ•ˆ
        function playEatSound() {
            // åˆ›å»ºè¶…çº§æ¬¢ä¹çš„å®å½“å£°
            const notes = [261.63, 329.63, 392.00, 523.25, 659.25, 783.99, 1046.50]; // C4åˆ°C6
            
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.type = index % 2 === 0 ? 'sine' : 'triangle';
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    
                    // åŠ å…¥ä¸€ç‚¹é¢¤éŸ³æ•ˆæœ
                    const vibrato = audioContext.createOscillator();
                    vibrato.frequency.value = 5;
                    const vibratoGain = audioContext.createGain();
                    vibratoGain.gain.value = 10;
                    vibrato.connect(vibratoGain);
                    vibratoGain.connect(oscillator.frequency);
                    vibrato.start();
                    
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    vibrato.stop(audioContext.currentTime + 0.3);
                }, index * 40);
            });
        }
        
        // æ’­æ”¾å¤±è´¥éŸ³æ•ˆ
        function playMissSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        // æ’­æ”¾æŠ€èƒ½éŸ³æ•ˆ
        function playSkillSound() {
            // å‘å°„éŸ³æ•ˆ
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }
        
        // æ’­æ”¾å‡çº§éŸ³æ•ˆ
        function playLevelUpSound() {
            const notes = [261.63, 329.63, 392.00, 523.25, 659.25];
            
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                }, index * 100);
            });
        }
        
        // æ’­æ”¾æ¸¸æˆç»“æŸéŸ³æ•ˆ
        function playGameOverSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.5);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        // æ’­æ”¾é¢å¤–ç”Ÿå‘½éŸ³æ•ˆ
        function playExtraLifeSound() {
            const notes = [523.25, 587.33, 659.25, 783.99]; // C5, D5, E5, G5
            
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                }, index * 100);
            });
        }
        
        // å½©è™¹é¢œè‰²æ•°ç»„
        const rainbowColors = [
            '#FF0000', '#FF7F00', '#FFFF00', '#00FF00', 
            '#0000FF', '#4B0082', '#9400D3'
        ];
        
        // é£Ÿç‰©è¡¨æƒ…
        const foodEmojis = ['ğŸ', 'ğŸ“', 'ğŸŠ', 'ğŸ‹', 'ğŸ‡', 'ğŸ‰', 'ğŸ’', 'ğŸŒ', 'ğŸ¥', 'ğŸ‘'];
        
        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(message, x, y) {
            const msg = document.createElement('div');
            msg.className = 'message-popup';
            msg.textContent = message;
            msg.style.left = (canvas.offsetLeft + x * gridSize) + 'px';
            msg.style.top = (canvas.offsetTop + y * gridSize - 40) + 'px';
            document.body.appendChild(msg);
            
            setTimeout(() => {
                msg.remove();
            }, 2000);
        }
        
        // æ›´æ–°ç”Ÿå‘½æ˜¾ç¤º
        function updateLivesDisplay() {
            if (currentLevel >= 4) {
                const hearts = '<span class="heart">â¤ï¸</span>'.repeat(lives);
                livesInfo.innerHTML = `ç”Ÿå‘½: ${hearts}`;
                livesInfo.style.display = 'block';
            } else {
                livesInfo.style.display = 'none';
            }
        }
        
        // ä½¿ç”¨æŠ€èƒ½
        function useSkill() {
            if (!gameRunning || gamePaused || skillCooldown > 0 || !skillUnlocked) return;
            
            const head = snake[0];
            let targetFood = null;
            let minDistance = Infinity;
            
            // æ‰¾åˆ°æœ€è¿‘çš„é£Ÿç‰©ï¼ˆä¸é™åˆ¶åŒä¸€è¡Œï¼‰
            foods.forEach(food => {
                const distance = Math.abs(food.x - head.x) + Math.abs(food.y - head.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    targetFood = food;
                }
            });
            
            if (targetFood) {
                // æ’­æ”¾æŠ€èƒ½éŸ³æ•ˆ
                playSkillSound();
                
                // åˆ›å»ºå‘å°„çš„å°é±¼
                const projectile = document.createElement('div');
                projectile.className = 'projectile';
                projectile.textContent = 'ğŸŸ';
                projectile.style.left = (canvas.offsetLeft + head.x * gridSize) + 'px';
                projectile.style.top = (canvas.offsetTop + head.y * gridSize) + 'px';
                document.body.appendChild(projectile);
                
                // ç§»åŠ¨å°é±¼åˆ°ç›®æ ‡ï¼ˆæ›²çº¿è·¯å¾„ï¼‰
                setTimeout(() => {
                    projectile.style.transition = 'all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    projectile.style.left = (canvas.offsetLeft + targetFood.x * gridSize) + 'px';
                    projectile.style.top = (canvas.offsetTop + targetFood.y * gridSize) + 'px';
                }, 50);
                
                // åƒæ‰é£Ÿç‰©
                setTimeout(() => {
                    projectile.remove();
                    
                    // ç§»é™¤é£Ÿç‰©å¹¶åŠ åˆ†
                    const foodIndex = foods.indexOf(targetFood);
                    if (foodIndex !== -1) {
                        foods.splice(foodIndex, 1);
                        score += 10;
                        scoreElement.textContent = score;
                        playEatSound();
                        createFoodEffect(targetFood.x, targetFood.y, targetFood.emoji);
                        generateSingleFood();
                        
                        // è›‡ä¹Ÿè¦å˜é•¿
                        snake.push({...snake[snake.length - 1]});
                    }
                }, 550);
                
                // å¼€å§‹å†·å´
                skillCooldown = 30;
                updateSkillButton();
                
                if (skillCooldownInterval) {
                    clearInterval(skillCooldownInterval);
                }
                
                skillCooldownInterval = setInterval(() => {
                    skillCooldown--;
                    updateSkillButton();
                    if (skillCooldown <= 0) {
                        clearInterval(skillCooldownInterval);
                        skillCooldownInterval = null;
                    }
                }, 1000);
            } else {
                // æ²¡æœ‰åŒè¡Œçš„é£Ÿç‰©
                playMissSound();
                showMessage("ä¸‹æ¬¡å†åŠªåŠ›ï¼", head.x, head.y);
            }
        }
        
        // æ›´æ–°æŠ€èƒ½æŒ‰é’®
        function updateSkillButton() {
            if (!skillUnlocked) {
                skillButton.style.display = 'none';
                skillInfo.textContent = '';
                return;
            }
            
            skillButton.style.display = 'block';
            
            if (skillCooldown > 0) {
                skillButton.disabled = true;
                skillButton.textContent = `æŠ€èƒ½å†·å´ä¸­ (${skillCooldown}ç§’)`;
                skillInfo.textContent = `â±ï¸ æŠ€èƒ½å†·å´: ${skillCooldown}ç§’`;
            } else {
                skillButton.disabled = false;
                skillButton.textContent = 'ä½¿ç”¨è¿œç¨‹åƒæŠ€èƒ½ (ç©ºæ ¼é”®)';
                skillInfo.textContent = 'ğŸŸ è¿œç¨‹åƒæŠ€èƒ½å·²å°±ç»ªï¼';
            }
        }
        
        // ç”Ÿæˆå•ä¸ªé£Ÿç‰©
        function generateSingleFood() {
            let newFood;
            let attempts = 0;
            do {
                newFood = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    emoji: foodEmojis[Math.floor(Math.random() * foodEmojis.length)]
                };
                attempts++;
                let valid = true;
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        valid = false;
                        break;
                    }
                }
                for (let food of foods) {
                    if (food.x === newFood.x && food.y === newFood.y) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    foods.push(newFood);
                    return;
                }
            } while (attempts < 100);
        }
        
        // åˆå§‹åŒ–é£Ÿç‰©
        function initializeFoods() {
            foods = [];
            for (let i = 0; i < 3; i++) {
                generateSingleFood();
            }
        }
        
        // åˆ›å»ºé£Ÿç‰©åŠ¨ç”»æ•ˆæœ
        function createFoodEffect(x, y, emoji) {
            const effect = document.createElement('div');
            effect.className = 'food-effect';
            effect.textContent = emoji;
            effect.style.left = (canvas.offsetLeft + x * gridSize) + 'px';
            effect.style.top = (canvas.offsetTop + y * gridSize - 20) + 'px';
            document.body.appendChild(effect);
            
            setTimeout(() => {
                effect.remove();
            }, 500);
        }
        
        // ç»˜åˆ¶æ¸¸æˆ
        function draw() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶è›‡
            snake.forEach((segment, index) => {
                const colorIndex = index % rainbowColors.length;
                ctx.fillStyle = rainbowColors[colorIndex];
                ctx.fillRect(segment.x * gridSize + 2, segment.y * gridSize + 2, 
                           gridSize - 4, gridSize - 4);
                
                // ç»˜åˆ¶è›‡å¤´
                if (index === 0) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(segment.x * gridSize + 6, segment.y * gridSize + 6, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * gridSize + 14, segment.y * gridSize + 6, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(segment.x * gridSize + 6, segment.y * gridSize + 6, 1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * gridSize + 14, segment.y * gridSize + 6, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // ç»˜åˆ¶é£Ÿç‰©
            foods.forEach(food => {
                ctx.font = `${gridSize - 4}px Arial`;
                ctx.fillText(food.emoji, food.x * gridSize + 2, food.y * gridSize + gridSize - 4);
            });
        }
        
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update() {
            if (!gameRunning || gamePaused) return;
            
            if (dx === 0 && dy === 0) return;
            
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            
            // æ£€æŸ¥å¢™å£ç¢°æ’
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                handleDeath();
                return;
            }
            
            // æ£€æŸ¥è‡ªèº«ç¢°æ’
            for (let segment of snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    handleDeath();
                    return;
                }
            }
            
            snake.unshift(head);
            
            // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
            let ateFood = false;
            for (let i = 0; i < foods.length; i++) {
                if (head.x === foods[i].x && head.y === foods[i].y) {
                    score += 10;
                    scoreElement.textContent = score;
                    
                    playEatSound();
                    createFoodEffect(foods[i].x, foods[i].y, foods[i].emoji);
                    
                    foods.splice(i, 1);
                    generateSingleFood();
                    
                    ateFood = true;
                    break;
                }
            }
            
            if (!ateFood) {
                snake.pop();
            }
            
            // æ£€æŸ¥æ˜¯å¦é€šå…³
            if (score >= currentLevel * 30) {
                levelComplete();
            }
            
            draw();
        }
        
        // å¤„ç†æ­»äº¡
        function handleDeath() {
            if (lives > 1) {
                lives--;
                updateLivesDisplay();
                playMissSound();
                showMessage("è¿˜æœ‰ä¸€æ¬¡æœºä¼šï¼", 10, 10);
                
                // é‡ç½®è›‡çš„ä½ç½®
                snake = [{x: 10, y: 10}];
                dx = 0;
                dy = 0;
                draw();
            } else {
                gameOver();
            }
        }
        
        // å…³å¡å®Œæˆ
        function levelComplete() {
            gameRunning = false;
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
            
            // ç´¯åŠ æ€»åˆ†
            totalGameScore += score;
            
            if (!completedLevels.includes(currentLevel)) {
                completedLevels.push(currentLevel);
                localStorage.setItem('completedLevels', JSON.stringify(completedLevels));
            }
            
            // ç¬¬ä¸€å…³å®Œæˆè§£é”æŠ€èƒ½
            if (currentLevel === 1 && !skillUnlocked) {
                skillUnlocked = true;
                localStorage.setItem('skillUnlocked', 'true');
                alert('æ­å–œï¼ä½ è§£é”äº†è¿œç¨‹åƒæŠ€èƒ½ï¼æŒ‰ç©ºæ ¼é”®ä½¿ç”¨ï¼');
            }
            
            playLevelUpSound();
            
            if (currentLevel === 7) {
                alert(`æ­å–œé€šè¿‡æ‰€æœ‰å…³å¡ï¼æ€»åˆ†: ${totalGameScore}`);
                finalScoreElement.textContent = score;
                totalScoreElement.textContent = totalGameScore;
                overlay.style.display = 'block';
                gameOverDiv.style.display = 'block';
            } else {
                alert(`æ­å–œé€šè¿‡ç¬¬${currentLevel}å…³ï¼`);
                showLevelSelect();
            }
        }
        
        // æ¸¸æˆç»“æŸ
        function gameOver() {
            gameRunning = false;
            playGameOverSound();
            
            // ç´¯åŠ æ€»åˆ†
            totalGameScore += score;
            
            finalScoreElement.textContent = score;
            totalScoreElement.textContent = totalGameScore;
            overlay.style.display = 'block';
            gameOverDiv.style.display = 'block';
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
            if (skillCooldownInterval) {
                clearInterval(skillCooldownInterval);
                skillCooldownInterval = null;
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦è¿›å…¥æ’è¡Œæ¦œ
        function checkHighScore() {
            const leaderboard = getLeaderboard();
            
            if (leaderboard.length < 10 || totalGameScore > leaderboard[9].score) {
                highScoreDisplay.textContent = totalGameScore;
                overlay.style.display = 'block';
                gameOverDiv.style.display = 'none';
                nameInputModal.style.display = 'block';
            } else {
                showLeaderboard();
            }
        }
        
        // æäº¤é«˜åˆ†
        function submitHighScore() {
            const playerName = document.getElementById('playerName').value.trim();
            
            if (!playerName) {
                alert('è¯·è¾“å…¥ä½ çš„åå­—ï¼');
                return;
            }
            
            const leaderboard = getLeaderboard();
            const date = new Date().toLocaleDateString('zh-CN');
            
            leaderboard.push({
                name: playerName,
                score: totalGameScore,
                date: date
            });
            
            // æ’åºå¹¶ä¿ç•™å‰10å
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard.splice(10);
            
            localStorage.setItem('snakeLeaderboard', JSON.stringify(leaderboard));
            
            nameInputModal.style.display = 'none';
            showLeaderboard();
        }
        
        // å–æ¶ˆæäº¤
        function cancelSubmit() {
            nameInputModal.style.display = 'none';
            showLevelSelect();
        }
        
        // è·å–æ’è¡Œæ¦œ
        function getLeaderboard() {
            const saved = localStorage.getItem('snakeLeaderboard');
            return saved ? JSON.parse(saved) : [];
        }
        
        // æ˜¾ç¤ºæ’è¡Œæ¦œ
        function showLeaderboard() {
            const leaderboard = getLeaderboard();
            const tbody = document.getElementById('leaderboardBody');
            
            tbody.innerHTML = '';
            
            leaderboard.forEach((entry, index) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = index + 1;
                row.insertCell(1).textContent = entry.name;
                row.insertCell(2).textContent = entry.score + ' åˆ†';
                row.insertCell(3).textContent = entry.date;
            });
            
            if (leaderboard.length === 0) {
                const row = tbody.insertRow();
                const cell = row.insertCell(0);
                cell.colSpan = 4;
                cell.textContent = 'æš‚æ— è®°å½•';
                cell.style.textAlign = 'center';
            }
            
            overlay.style.display = 'block';
            leaderboardModal.style.display = 'block';
            gameOverDiv.style.display = 'none';
            nameInputModal.style.display = 'none';
        }
        
        // å…³é—­æ’è¡Œæ¦œ
        function closeLeaderboard() {
            leaderboardModal.style.display = 'none';
            overlay.style.display = 'none';
        }
        
        // æ˜¾ç¤ºå…³å¡é€‰æ‹©
        function showLevelSelect() {
            overlay.style.display = 'block';
            levelSelectDiv.style.display = 'block';
            gameOverDiv.style.display = 'none';
            totalGameScore = 0; // é‡ç½®æ€»åˆ†
            
            updateLevelButtons();
        }
        
        // æ›´æ–°å…³å¡æŒ‰é’®
        function updateLevelButtons() {
            // æ›´æ–°è§£é”çŠ¶æ€
            for (let i = 2; i <= 7; i++) {
                const button = document.getElementById(`level${i}Button`);
                if (completedLevels.includes(i - 1)) {
                    button.disabled = false;
                } else {
                    button.disabled = true;
                    button.textContent = `ç¬¬${i}å…³ - éœ€è¦é€šè¿‡ç¬¬${i-1}å…³`;
                }
            }
            
            // æ¢å¤æŒ‰é’®æ–‡æœ¬
            if (!document.getElementById('level2Button').disabled) {
                document.getElementById('level2Button').textContent = 'ç¬¬2å…³ - æ­£å¸¸é€Ÿåº¦ ğŸ';
            }
            if (!document.getElementById('level3Button').disabled) {
                document.getElementById('level3Button').textContent = 'ç¬¬3å…³ - å¿«å¿«è·‘ ğŸš€';
            }
            if (!document.getElementById('level4Button').disabled) {
                document.getElementById('level4Button').textContent = 'ç¬¬4å…³ - è¶…çº§å¿« âš¡ (+1å‘½)';
            }
            if (!document.getElementById('level5Button').disabled) {
                document.getElementById('level5Button').textContent = 'ç¬¬5å…³ - é—ªç”µä¾  âš¡âš¡';
            }
            if (!document.getElementById('level6Button').disabled) {
                document.getElementById('level6Button').textContent = 'ç¬¬6å…³ - å…‰é€Ÿ ğŸ’«';
            }
            if (!document.getElementById('level7Button').disabled) {
                document.getElementById('level7Button').textContent = 'ç¬¬7å…³ - ç»ˆææŒ‘æˆ˜ ğŸ”¥';
            }
        }
        
        // å¼€å§‹ç‰¹å®šå…³å¡
        function startLevel(level) {
            currentLevel = level;
            levelElement.textContent = level;
            
            // æ ¹æ®å…³å¡è®¾ç½®é€Ÿåº¦å’Œç”Ÿå‘½
            switch(level) {
                case 1:
                    gameSpeed = 200;
                    maxLives = 1;
                    break;
                case 2:
                    gameSpeed = 150;
                    maxLives = 1;
                    break;
                case 3:
                    gameSpeed = 120;
                    maxLives = 1;
                    break;
                case 4:
                    gameSpeed = 100;
                    maxLives = 2; // é¢å¤–ä¸€æ¡å‘½
                    break;
                case 5:
                    gameSpeed = 80;
                    maxLives = 2;
                    break;
                case 6:
                    gameSpeed = 70;
                    maxLives = 2;
                    break;
                case 7:
                    gameSpeed = 60;
                    maxLives = 2;
                    break;
            }
            
            lives = maxLives;
            updateLivesDisplay();
            
            overlay.style.display = 'none';
            levelSelectDiv.style.display = 'none';
            
            // æ›´æ–°æŠ€èƒ½æ˜¾ç¤º
            if (skillUnlocked) {
                skillInstruction.style.display = 'block';
            }
            
            if (level === 4 && maxLives === 2) {
                playExtraLifeSound();
                showMessage("è·å¾—é¢å¤–ç”Ÿå‘½ï¼", 10, 10);
            }
            
            playLevelUpSound();
            startGame();
        }
        
        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gamePaused) return;
            
            switch(e.key) {
                case 'ArrowUp':
                    if (dy === 0) {
                        dx = 0;
                        dy = -1;
                    }
                    break;
                case 'ArrowDown':
                    if (dy === 0) {
                        dx = 0;
                        dy = 1;
                    }
                    break;
                case 'ArrowLeft':
                    if (dx === 0) {
                        dx = -1;
                        dy = 0;
                    }
                    break;
                case 'ArrowRight':
                    if (dx === 0) {
                        dx = 1;
                        dy = 0;
                    }
                    break;
                case ' ':
                    e.preventDefault();
                    useSkill();
                    break;
            }
        });
        
        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            
            snake = [{x: 10, y: 10}];
            dx = 0;
            dy = 0;
            score = 0;
            scoreElement.textContent = score;
            skillCooldown = 0;
            initializeFoods();
            gameRunning = true;
            gamePaused = false;
            
            updateSkillButton();
            
            gameInterval = setInterval(update, gameSpeed);
            
            draw();
        }
        
        // æš‚åœæ¸¸æˆ
        function pauseGame() {
            if (gameRunning) {
                gamePaused = !gamePaused;
            }
        }
        
        // é‡æ–°å¼€å§‹
        function restartGame() {
            overlay.style.display = 'none';
            gameOverDiv.style.display = 'none';
            totalGameScore = 0;
            startLevel(currentLevel);
        }
        
        // åŠ è½½ä¿å­˜çš„è¿›åº¦
        function loadProgress() {
            const saved = localStorage.getItem('completedLevels');
            if (saved) {
                completedLevels = JSON.parse(saved);
            }
            
            const skillSaved = localStorage.getItem('skillUnlocked');
            if (skillSaved === 'true') {
                skillUnlocked = true;
            }
        }
        
        // åˆå§‹åŒ–
        loadProgress();
        initializeFoods();
        draw();
    </script>
</body>
</html>
